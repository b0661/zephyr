/*
 * Copyright (c) 2018 Bobby Noelte
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/** @file
 * @brief STM32 pinctrl implementation
 * @defgroup device_driver_pinctrl_stm32 STM32 pinctrl inplementation
 *
 * A common driver for STM32 pinctrl. SoC specific adaptions are
 * done by device tree and soc.h.
 *
 * @{
 */

/* Keep this first */
#include "../driver_lib.h"

/* Compile if at least one device is activated */
#if DRIVER_COMPATIBLE(PIN, ST_STM32_PINCTRL)

/* -------------------------------------------------
 * Driver configuration data from kernel config.
 * <autoconf.h> is automatically included
 * -------------------------------------------------
 * - None
 */

/* -------------------------------------------------
 * Driver configuration data from device tree.
 * <generated_dts_board.h> is automatically included
 * -------------------------------------------------
 */
/**
 * @def SOC_PIN_CONTROLLER_COUNT
 * @brief Number auf pin controllers activated in device tree.
 *
 * @def SOC_PIN_CONTROLLER_0
 * @brief Prefix of autogenerated defines for a pin controller.
 */
#include <pinctrl_common.h>
#include <dt-bindings/clock/stm32_clock.h>
#include <dt-bindings/pinctrl/pinctrl_stm32.h>

#include <errno.h>
#include <string.h>
#include <zephyr/types.h>
#include <misc/__assert.h>
#include <misc/util.h>
#include <kernel.h>
#include <device.h>
#include <gpio.h>
#include <pinctrl.h>

#include <clock_control/stm32_clock_control.h>

#include <chaos/preprocessor/array/elem.h>
#include <chaos/preprocessor/cat.h>
#include <chaos/preprocessor/detection/is_empty.h>
#include <chaos/preprocessor/control/unless.h>
#include <chaos/preprocessor/control/when.h>
#include <chaos/preprocessor/repetition/repeat_from_to.h>

/* Driver Settings from device tree
 * - PINCTRL_STM32_PREFIX
 */
#define PINCTRL_STM32_PREFIX DRIVER_DTS_PREFIX(PIN, 0)

/**
 * @def PINCTRL_STM32_GPIO_COUNT
 * @brief Number of GPIO ports that may be managed by the pinctrl driver.
 *
 * This is the total number of GPIO ports available. The number of aktivated
 * GPIO ports may be less.
 */
/* GPIOx is defined by the STM32 CubeMX library. */
#if defined(GPIOK)
#define PINCTRL_STM32_GPIO_COUNT 11
#elif defined(GPIOJ)
#define PINCTRL_STM32_GPIO_COUNT 10
#elif defined(GPIOI)
#define PINCTRL_STM32_GPIO_COUNT 9
#elif defined(GPIOH)
#define PINCTRL_STM32_GPIO_COUNT 8
#elif defined(GPIOG)
#define PINCTRL_STM32_GPIO_COUNT 7
#elif defined(GPIOF)
#define PINCTRL_STM32_GPIO_COUNT 6
#elif defined(GPIOE)
#define PINCTRL_STM32_GPIO_COUNT 5
#elif defined(GPIOD)
#define PINCTRL_STM32_GPIO_COUNT 4
#elif defined(GPIOC)
#define PINCTRL_STM32_GPIO_COUNT 3
#elif defined(GPIOB)
#define PINCTRL_STM32_GPIO_COUNT 2
#elif defined(GPIOA)
#define PINCTRL_STM32_GPIO_COUNT 1
#else
#error "Missing GPIOx definition!"
#endif

/*
 * Check for an unavailable GPIO.
 */
/* GPIOx is defined by the STM32 CubeMX library. */
#if !defined(GPIOK)
#define GPIOK
#endif
#if !defined(GPIOJ)
#define GPIOJ
#endif
#if !defined(GPIOI)
#define GPIOI
#endif
#if !defined(GPIOH)
#define GPIOH
#endif
#if !defined(GPIOG)
#define GPIOG
#endif
#if !defined(GPIOF)
#define GPIOF
#endif
#if !defined(GPIOE)
#define GPIOE
#endif
#if !defined(GPIOD)
#define GPIOD
#endif
#if !defined(GPIOC)
#define GPIOC
#endif
#if !defined(GPIOB)
#define GPIOB
#endif
#if !defined(GPIOA)
#define GPIOA
#endif

/**
 * @def PINCTRL_STM32_PIN_COUNT
 * @brief Number of pins that may be managed by the pinctrl driver.
 */
#define PINCTRL_STM32_PIN_COUNT (PINCTRL_STM32_GPIO_COUNT * 16)

/**
 * @def PINCTRL_STM32_LL_BUS_GPIO
 * @brief Bus the GPIOs are connected to.
 *
 * Bus corresponds to STM32 CubeMX library LL_<bus>_GRP1_PERIPH_GPIOx define.
 */
#if defined(CONFIG_SOC_SERIES_STM32F0X) ||     \
	defined(CONFIG_SOC_SERIES_STM32F3X) || \
	defined(CONFIG_SOC_SERIES_STM32F4X) || \
	defined(CONFIG_SOC_SERIES_STM32F7X)
#define PINCTRL_STM32_LL_BUS_GPIO AHB1
#elif defined(CONFIG_SOC_SERIES_STM32F1X)
#define PINCTRL_STM32_LL_BUS_GPIO APB2
#elif defined(CONFIG_SOC_SERIES_STM32L4X)
#define PINCTRL_STM32_LL_BUS_GPIO AHB2
#endif

/**
 * @def PINCTRL_STM32_PORTS
 * @brief CHAOS_PP array of GPIO port identifiers [A..K].
 *
 * Array maps numeric port index to lexical port indentifier.
 */
#define PINCTRL_STM32_PORTS() (11, (A, B, C, D, E, F, G, H, I, J, K))

/**
 * @def PINCTRL_STM32_GPIO
 * @brief Helper for GPIO info initialization.
 *
 * Creates an initialization for a GPIO info with index idx.
 *
 * To be used by CHAOS_PP_REPEAT_FROM_TO the signature must be of macro(s, n).
 */
#define PINCTRL_STM32_GPIO(s, idx) _PINCTRL_STM32_GPIO1(idx)
#define _PINCTRL_STM32_GPIO1(idx)                       \
	_PINCTRL_STM32_GPIO2(PINCTRL_STM32_LL_BUS_GPIO, \
			     CHAOS_PP_ARRAY_ELEM(idx, PINCTRL_STM32_PORTS()))
#define _PINCTRL_STM32_GPIO2(_bus, _port_id) \
	_PINCTRL_STM32_GPIO3(_bus, _port_id)
#define _PINCTRL_STM32_GPIO3(_bus, _port_id)                         \
	_PINCTRL_STM32_GPIO4(LL_##_bus##_GRP1_PERIPH_GPIO##_port_id, \
			     CHAOS_PP_CAT(GPIO, _port_id))
#define _PINCTRL_STM32_GPIO4(_enr, _port)                      \
	{                                                      \
	CHAOS_PP_UNLESS(CHAOS_PP_IS_EMPTY_NON_FUNCTION(_port)) \
	(                                                      \
		.ll_gpio_pclken_enr = _enr,                    \
		.ll_gpio_port = _port,                         \
	)                                                      \
	CHAOS_PP_WHEN(CHAOS_PP_IS_EMPTY_NON_FUNCTION(_port))   \
	(                                                      \
		.ll_gpio_pclken_enr = 0,                       \
		.ll_gpio_port = 0,                             \
	)                                                      \
	},

/**
 * @brief Extract mux value from device tree pinmux.
 *
 * @note Device tree pinmux expands to a tuple (pin, mux).
 */
#define PINCTRL_STM32_PINCONF_PINMUX_MUX(pin, mux) mux

/**
 * @brief Extract pin value from device tree pinmux.
 *
 * @note Device tree pinmux expands to a tuple (pin, mux).
 */
#define PINCTRL_STM32_PINCONF_PINMUX_PIN(pin, mux) pin

/**
 * @brief Driver data
 */
struct pinctrl_stm32_data_s {
	/** clock control device */
	struct device *clk;
	/** Peripherial bus clock enable info for gpio devices */
	struct stm32_pclken pclken_gpio;
} pinctrl_stm32_data;

/**
 * @brief GPIO info.
 */
struct pinctrl_stm32_gpio {
	u32_t ll_gpio_pclken_enr;
	GPIO_TypeDef *ll_gpio_port;
};

/**
 * @brief GPIO data.
 */
static const struct pinctrl_stm32_gpio
	pinctrl_stm32_gpio_data[PINCTRL_STM32_GPIO_COUNT] = {
		CHAOS_PP_EXPR(CHAOS_PP_REPEAT_FROM_TO(
			0, PINCTRL_STM32_GPIO_COUNT, PINCTRL_STM32_GPIO))};

/**
 * @brief Convert pin number to STM32CubeMX GPIO port descriptor.
 *
 * @param pin Pin number
 * @return STM32CubeMX GPIO port descriptor
 */
static GPIO_TypeDef *pinctrl_stm32_ll_gpio_port(u16_t pin)
{
	int port_idx = (pin >> 4) & 0x0F;

	__ASSERT((port_idx < PINCTRL_STM32_GPIO_COUNT),
		 "pin unknown - no GPIO port descriptor");
	__ASSERT((pinctrl_stm32_gpio_data[port_idx].ll_gpio_port != 0),
		 "pin unknown - no GPIO port descriptor");

	return pinctrl_stm32_gpio_data[port_idx].ll_gpio_port;
}

/**
 * @brief Convert pin number to STM32CubeMX GPIO pin descriptor.
 *
 * @param pin Pin number
 * @return STM32CubeMX GPIO pin descriptor
 */
static inline u32_t pinctrl_stm32_ll_gpio_pin(u16_t pin)
{
	return 0x01U << (pin & 0x0F);
}

/**
 * @brief Get STM32CubeMX GPIO mode associated to function.
 *
 * @param func Function
 * @return STM32CubeMX GPIO mode
 */
static u32_t pinctrl_stm32_ll_gpio_mode(u16_t func)
{
	switch (func) {
	case PINCTRL_STM32_FUNCTION_ALT_0:
	case PINCTRL_STM32_FUNCTION_ALT_1:
	case PINCTRL_STM32_FUNCTION_ALT_2:
	case PINCTRL_STM32_FUNCTION_ALT_3:
	case PINCTRL_STM32_FUNCTION_ALT_4:
	case PINCTRL_STM32_FUNCTION_ALT_5:
	case PINCTRL_STM32_FUNCTION_ALT_6:
	case PINCTRL_STM32_FUNCTION_ALT_7:
	case PINCTRL_STM32_FUNCTION_ALT_8:
	case PINCTRL_STM32_FUNCTION_ALT_9:
	case PINCTRL_STM32_FUNCTION_ALT_10:
	case PINCTRL_STM32_FUNCTION_ALT_11:
	case PINCTRL_STM32_FUNCTION_ALT_12:
	case PINCTRL_STM32_FUNCTION_ALT_13:
	case PINCTRL_STM32_FUNCTION_ALT_14:
	case PINCTRL_STM32_FUNCTION_ALT_15:
		return LL_GPIO_MODE_ALTERNATE;
	case PINCTRL_STM32_FUNCTION_INPUT:
		return LL_GPIO_MODE_INPUT;
	case PINCTRL_STM32_FUNCTION_OUTPUT:
		return LL_GPIO_MODE_OUTPUT;
	case PINCTRL_STM32_FUNCTION_ANALOG:
		return LL_GPIO_MODE_ANALOG;
	}
	__ASSERT(0, "function unknown - no LL_GPIO_MODE");
	return 0;
}

static inline u32_t pinctrl_stm32_ll_gpio_alt_func(u16_t func)
{
	if ((func >= PINCTRL_STM32_FUNCTION_ALT_0) &&
	    (func <= PINCTRL_STM32_FUNCTION_ALT_15)) {
		return func - PINCTRL_STM32_FUNCTION_ALT_0;
	}
	__ASSERT(0, "function unknown - no LL_GPIO_ALT_FUNC");
	return func;
}

/**
 * @brief Enable GPIO port to be clocked by associated peripherial bus clock.
 */
static void pinctrl_stm32_gpio_enable_clock(int port_idx)
{
	__ASSERT((port_idx < PINCTRL_STM32_GPIO_COUNT),
		 "port unknown - invalid port_idx");
	__ASSERT((pinctrl_stm32_gpio_data[port_idx].ll_gpio_port != 0),
		 "port unknown - invalid port_idx");

	/* pinctrl_stm32_data.pclken_gpio.bus already set by init */
	pinctrl_stm32_data.pclken_gpio.enr =
		pinctrl_stm32_gpio_data[port_idx].ll_gpio_pclken_enr;
	clock_control_on(
		pinctrl_stm32_data.clk,
		(clock_control_subsys_t)&pinctrl_stm32_data.pclken_gpio);
}

/* --- API (using the PINCTRL lib) --- */

/* forward declarations */
static int pinctrl_stm32_config_get(struct device *dev, u16_t pin,
				    u32_t *config);
static int pinctrl_stm32_config_set(struct device *dev, u16_t pin,
				    u32_t config);
static int pinctrl_stm32_mux_get(struct device *dev, u16_t pin, u16_t *func);
static int pinctrl_stm32_mux_set(struct device *dev, u16_t pin, u16_t func);
static int pinctrl_stm32_device_init(struct device *dev);

/* Configure PINCTRL library */
#define CONFIG_PINCTRL_LIB_SELECT_PINMUX 1
#define CONFIG_PINCTRL_LIB_ENABLE_MUX_REQUEST CONFIG_PINCTRL_MUX_REQUEST
#define CONFIG_PINCTRL_LIB_DEVICE_NAME_PREFIX pinctrl_stm32
#define CONFIG_PINCTRL_LIB_CONFIG_GET pinctrl_stm32_config_get
#define CONFIG_PINCTRL_LIB_CONFIG_SET pinctrl_stm32_config_set
#define CONFIG_PINCTRL_LIB_MUX_GET pinctrl_stm32_mux_get
#define CONFIG_PINCTRL_LIB_MUX_SET pinctrl_stm32_mux_set
#define CONFIG_PINCTRL_LIB_PINCONF_PINMUX_PIN PINCTRL_STM32_PINCONF_PINMUX_PIN
#define CONFIG_PINCTRL_LIB_PINCONF_PINMUX_MUX PINCTRL_STM32_PINCONF_PINMUX_MUX
#define CONFIG_PINCTRL_LIB_CONTROLLER_COUNT 1
#define CONFIG_PINCTRL_LIB_CONTROLLER_0_PREFIX PINCTRL_STM32_PREFIX
#define CONFIG_PINCTRL_LIB_CONTROLLER_0_DATA (&pinctrl_stm32_data)
#define CONFIG_PINCTRL_LIB_CONTROLLER_0_PIN_COUNT PINCTRL_STM32_PIN_COUNT
#define CONFIG_PINCTRL_LIB_CONTROLLER_0_DEVICE_INIT pinctrl_stm32_device_init

#include "pinctrl_lib.h"

/**
 * Get the configuration of a pin.
 *
 * The following configuration options are supported.
 *
 * Options set by configuration or mux function:
 *   - @ref PINCTRL_CONFIG_BIAS_DISABLE
 *
 * Options set by configuration:
 *   - @ref PINCTRL_CONFIG_BIAS_PULL_UP
 *   - @ref PINCTRL_CONFIG_BIAS_PULL_DOWN
 *   - @ref PINCTRL_CONFIG_DRIVE_PUSH_PULL
 *   - @ref PINCTRL_CONFIG_DRIVE_OPEN_DRAIN
 *   - @ref PINCTRL_CONFIG_SPEED_SLOW
 *   - @ref PINCTRL_CONFIG_SPEED_MEDIUM
 *   - @ref PINCTRL_CONFIG_SPEED_HIGH
 *
 * Options set/ forced by mux function only:
 *   - @ref PINCTRL_CONFIG_INPUT_ENABLE
 *   - @ref PINCTRL_CONFIG_INPUT_DISABLE
 *   - @ref PINCTRL_CONFIG_INPUT_SCHMITT_ENABLE
 *   - @ref PINCTRL_CONFIG_INPUT_SCHMITT_DISABLE
 *   - @ref PINCTRL_CONFIG_OUTPUT_ENABLE
 *   - @ref PINCTRL_CONFIG_OUTPUT_DISABLE
 *
 * @param dev Pointer to the device structure for the driver instance.
 * @param pin Pin
 * @param config
 * @retval 0 on success
 * @retval -ENOTSUP if requested pin is not available on this controller
 * @retval -EINVAL if requested pin is available but disabled
 */
static int pinctrl_stm32_config_get(struct device *dev, u16_t pin,
				    u32_t *config)
{
	ARG_UNUSED(dev);

	if (pin >= PINCTRL_STM32_PIN_COUNT) {
		return -ENOTSUP;
	}

	*config = 0;

	GPIO_TypeDef *ll_gpio_port = pinctrl_stm32_ll_gpio_port(pin);
	u32_t ll_gpio_pin = pinctrl_stm32_ll_gpio_pin(pin);

	/* current pin mode (muxing function) */
	switch (LL_GPIO_GetPinMode(ll_gpio_port, ll_gpio_pin)) {
	case LL_GPIO_MODE_ALTERNATE:
		*config |= PINCTRL_CONFIG_OUTPUT_ENABLE |
			   PINCTRL_CONFIG_INPUT_ENABLE |
			   PINCTRL_CONFIG_INPUT_SCHMITT_ENABLE;
		break;
	case LL_GPIO_MODE_OUTPUT:
		*config |= PINCTRL_CONFIG_OUTPUT_ENABLE |
			   PINCTRL_CONFIG_INPUT_ENABLE |
			   PINCTRL_CONFIG_INPUT_SCHMITT_ENABLE;
		break;
	case LL_GPIO_MODE_INPUT:
		*config |= PINCTRL_CONFIG_INPUT_ENABLE |
			   PINCTRL_CONFIG_OUTPUT_DISABLE |
			   PINCTRL_CONFIG_INPUT_SCHMITT_ENABLE;
		break;
	case LL_GPIO_MODE_ANALOG:
		*config |= PINCTRL_CONFIG_OUTPUT_DISABLE |
			   PINCTRL_CONFIG_INPUT_DISABLE |
			   PINCTRL_CONFIG_INPUT_SCHMITT_DISABLE |
			   PINCTRL_CONFIG_BIAS_DISABLE;
		break;
	}

	if (!(*config | PINCTRL_CONFIG_BIAS_DISABLE)) {
		switch (LL_GPIO_GetPinOutputType(ll_gpio_port, ll_gpio_pin)) {
		case LL_GPIO_OUTPUT_PUSHPULL:
			*config |= PINCTRL_CONFIG_BIAS_DISABLE;
			break;
		case LL_GPIO_PULL_UP:
			*config |= PINCTRL_CONFIG_BIAS_PULL_UP;
			break;
		case LL_GPIO_PULL_DOWN:
			*config |= PINCTRL_CONFIG_BIAS_PULL_DOWN;
			break;
		}
	}

	switch (LL_GPIO_GetPinSpeed(ll_gpio_port, ll_gpio_pin)) {
	case LL_GPIO_SPEED_FREQ_LOW:
		*config |= PINCTRL_CONFIG_SPEED_SLOW;
		break;
	case LL_GPIO_SPEED_FREQ_MEDIUM:
		*config |= PINCTRL_CONFIG_SPEED_MEDIUM;
		break;
	case LL_GPIO_SPEED_FREQ_HIGH:
		*config |= PINCTRL_CONFIG_SPEED_HIGH;
		break;
	}

	switch (LL_GPIO_GetPinOutputType(ll_gpio_port, ll_gpio_pin)) {
	case LL_GPIO_OUTPUT_PUSHPULL:
		*config |= PINCTRL_CONFIG_DRIVE_PUSH_PULL;
		break;
	case LL_GPIO_OUTPUT_OPENDRAIN:
		*config |= PINCTRL_CONFIG_DRIVE_OPEN_DRAIN;
		break;
	}

	return 0;
}

/**
 * @brief Configure a pin.
 *
 * The following configuration options are supported:
 *   - @ref PINCTRL_CONFIG_BIAS_DISABLE
 *   - @ref PINCTRL_CONFIG_BIAS_PULL_UP
 *   - @ref PINCTRL_CONFIG_BIAS_PULL_DOWN
 *   - @ref PINCTRL_CONFIG_BIAS_PULL_PIN_DEFAULT
 *   - @ref PINCTRL_CONFIG_DRIVE_PUSH_PULL
 *   - @ref PINCTRL_CONFIG_DRIVE_OPEN_DRAIN
 *   - @ref PINCTRL_CONFIG_SPEED_SLOW
 *   - @ref PINCTRL_CONFIG_SPEED_MEDIUM
 *   - @ref PINCTRL_CONFIG_SPEED_FAST
 *   - @ref PINCTRL_CONFIG_SPEED_HIGH
 *
 * @note For safety purposes the pin should be reset to input before
 * configuration.
 *
 * @param dev Pointer to the device structure for the driver instance.
 * @param pin Pin
 * @param config
 * @retval 0 on success
 * @retval -ENOTSUP if requested pin is not available on this controller
 */
static int pinctrl_stm32_config_set(struct device *dev, u16_t pin, u32_t config)
{
	ARG_UNUSED(dev);

	if (pin >= PINCTRL_STM32_PIN_COUNT) {
		return -ENOTSUP;
	}

	u32_t ll_gpio_output_type = LL_GPIO_OUTPUT_PUSHPULL;
	u32_t ll_gpio_speed = LL_GPIO_SPEED_FREQ_LOW;
	u32_t ll_gpio_pull = LL_GPIO_PULL_NO;

	GPIO_TypeDef *ll_gpio_port = pinctrl_stm32_ll_gpio_port(pin);
	u32_t ll_gpio_pin = pinctrl_stm32_ll_gpio_pin(pin);

	switch (config & PINCTRL_CONFIG_SPEED_HIGH) {
	case PINCTRL_CONFIG_SPEED_SLOW:
		ll_gpio_speed = LL_GPIO_SPEED_FREQ_LOW;
		break;
	case PINCTRL_CONFIG_SPEED_MEDIUM:
		ll_gpio_speed = LL_GPIO_SPEED_FREQ_MEDIUM;
		break;
	case PINCTRL_CONFIG_SPEED_FAST:
	case PINCTRL_CONFIG_SPEED_HIGH:
		ll_gpio_speed = LL_GPIO_SPEED_FREQ_HIGH;
		break;
	}
	LL_GPIO_SetPinSpeed(ll_gpio_port, ll_gpio_pin, ll_gpio_speed);

	if (config & (PINCTRL_CONFIG_BIAS_DISABLE |
		      PINCTRL_CONFIG_BIAS_PULL_PIN_DEFAULT)) {
		ll_gpio_pull = LL_GPIO_PULL_NO;
	} else if (config & PINCTRL_CONFIG_BIAS_PULL_UP) {
		ll_gpio_pull = LL_GPIO_PULL_UP;
	} else if (config & PINCTRL_CONFIG_BIAS_PULL_DOWN) {
		ll_gpio_pull = LL_GPIO_PULL_DOWN;
	}
	LL_GPIO_SetPinPull(ll_gpio_port, ll_gpio_pin, ll_gpio_pull);

	if (config & PINCTRL_CONFIG_DRIVE_OPEN_DRAIN) {
		ll_gpio_output_type = LL_GPIO_OUTPUT_OPENDRAIN;
	} else if (config & PINCTRL_CONFIG_DRIVE_PUSH_PULL) {
		ll_gpio_output_type = LL_GPIO_OUTPUT_PUSHPULL;
	}
	LL_GPIO_SetPinOutputType(
		ll_gpio_port, ll_gpio_pin, ll_gpio_output_type);

	return 0;
}

/**
 * @brief Get muxing function at pin
 *
 * @param dev Pointer to the device structure for the driver instance.
 * @param pin Pin
 * @param[out] func Muxing function
 * @retval 0 on success
 * @retval -ENOTSUP if requested pin is not available on this controller
 */
static int pinctrl_stm32_mux_get(struct device *dev, u16_t pin, u16_t *func)
{
	ARG_UNUSED(dev);

	if (pin >= PINCTRL_STM32_PIN_COUNT) {
		return -ENOTSUP;
	}

	GPIO_TypeDef *ll_gpio_port = pinctrl_stm32_ll_gpio_port(pin);
	u32_t ll_gpio_pin = pinctrl_stm32_ll_gpio_pin(pin);

	/* current pin mode (muxing function) */
	switch (LL_GPIO_GetPinMode(ll_gpio_port, ll_gpio_pin)) {
	case LL_GPIO_MODE_ALTERNATE:
		if (ll_gpio_pin <= LL_GPIO_PIN_7) {
			*func = LL_GPIO_GetAFPin_0_7(ll_gpio_port, ll_gpio_pin);
		} else {
			*func = LL_GPIO_GetAFPin_8_15(ll_gpio_port,
						      ll_gpio_pin);
		}
		*func += PINCTRL_STM32_FUNCTION_ALT_0;
		break;
	case LL_GPIO_MODE_OUTPUT:
		*func = PINCTRL_STM32_FUNCTION_OUTPUT;
		break;
	case LL_GPIO_MODE_INPUT:
		*func = PINCTRL_STM32_FUNCTION_INPUT;
		break;
	case LL_GPIO_MODE_ANALOG:
		*func = PINCTRL_STM32_FUNCTION_ANALOG;
		break;
	}

	return 0;
}

/**
 * @brief Set muxing function at pin
 *
 * @param dev Pointer to the device structure for the driver instance.
 * @param pin Pin
 * @param func Muxing function
 * @retval 0 on success
 * @retval -ENOTSUP if requested pin is not available on this controller
 * @retval -EINVAL if requested function is unknown
 */
static int pinctrl_stm32_mux_set(struct device *dev, u16_t pin, u16_t func)
{
	if (pin >= PINCTRL_STM32_PIN_COUNT) {
		return -ENOTSUP;
	}

	const struct pinctrl_lib_config *config =
		pinctrl_lib_device_config_info(dev);

	if (pinctrl_is_device_function(func)) {
		/* Get hardware pinmux control for pin
		 * from a pinctrl for the device function.
		 */
		for (int i = 0; i < config->pinctrl_count; i++) {
			u16_t pinctrl_state = config->pinctrl_data[i].state;
			u16_t pinctrl_func =
				config->pinctrl_state_data[pinctrl_state]
					.function;
			u16_t pinctrl_pin = config->pinctrl_data[i].pin;

			if ((pinctrl_func == func) && (pinctrl_pin == pin)) {
				func = config->pinctrl_data[i].mux;
				break;
			}
		}
	}
	if (!pinctrl_is_pinmux_function(func)) {
		return -EINVAL;
	}
	/* now func denotes a hardware pinmux control */
	GPIO_TypeDef *ll_gpio_port = pinctrl_stm32_ll_gpio_port(pin);
	u32_t ll_gpio_pin = pinctrl_stm32_ll_gpio_pin(pin);

	if (pinctrl_stm32_ll_gpio_alt_func(func) <= LL_GPIO_AF_7) {
		/* valid alternate function */
		if (pinctrl_stm32_ll_gpio_pin(pin) <= LL_GPIO_PIN_7) {
			LL_GPIO_SetAFPin_0_7(
				ll_gpio_port,
				ll_gpio_pin,
				pinctrl_stm32_ll_gpio_alt_func(func));
		} else {
			LL_GPIO_SetAFPin_8_15(
				ll_gpio_port,
				ll_gpio_pin,
				pinctrl_stm32_ll_gpio_alt_func(func));
		}
	}
	LL_GPIO_SetPinMode(
		ll_gpio_port, ll_gpio_pin, pinctrl_stm32_ll_gpio_mode(func));
	return 0;
}

/**
 * @brief Initialise pin controller.
 *
 * Enable all GPIOS controlled by the pin controller (currently all GPIOs)
 * to be clocked by the associated peripherial bus clock.
 *
 * @param dev Pointer to the device structure for the driver instance.
 */
static int pinctrl_stm32_device_init(struct device *dev)
{
	ARG_UNUSED(dev);

	/* Enable all GPIOS to be clocked by the associated peripherial bus
	 * clock
	 */
	pinctrl_stm32_data.clk = device_get_binding(STM32_CLOCK_CONTROL_NAME);
	pinctrl_stm32_data.pclken_gpio.bus =
		CHAOS_PP_CAT(STM32_CLOCK_BUS_, PINCTRL_STM32_LL_BUS_GPIO);
	for (int port_idx = 0; port_idx < PINCTRL_STM32_GPIO_COUNT;
	     port_idx++) {
		pinctrl_stm32_gpio_enable_clock(port_idx);
	}

	return 0;
}

#endif /* #if DRIVER_COMPATIBLE(PIN, ST_STM32_PINCTRL) */

/** @} device_driver_pinctrl_stm32 */
